import {
  ChainNotConfiguredError,
  createConnector
} from "./chunk-WFJRQYN2.js";
import "./chunk-6FFXNDDO.js";
import "./chunk-I7WTGX7R.js";
import "./chunk-BI2WGPDD.js";
import "./chunk-5GL2KWOJ.js";
import "./chunk-GRAVF2X3.js";
import "./chunk-PUT4I3J5.js";
import {
  SwitchChainError,
  fromHex,
  getAddress,
  numberToHex
} from "./chunk-4V7ZOJSU.js";
import "./chunk-7XUA56FY.js";
import {
  dist_default
} from "./chunk-65MHWKED.js";
import "./chunk-VJXCOWQR.js";
import "./chunk-LJ7XLHFH.js";
import "./chunk-J32WSRGE.js";

// node_modules/@farcaster/miniapp-wagmi-connector/dist/connector.js
farcasterMiniApp.type = "farcasterMiniApp";
var accountsChanged;
var chainChanged;
var disconnect;
function farcasterMiniApp() {
  return createConnector((config) => ({
    id: "farcaster",
    name: "Farcaster",
    rdns: "xyz.farcaster.MiniAppWallet",
    icon: "https://imagedelivery.net/BXluQx4ige9GuW0Ia56BHw/055c25d6-7fe7-4a49-abf9-49772021cf00/original",
    type: farcasterMiniApp.type,
    async connect({ chainId } = {}) {
      var _a, _b;
      const provider = await this.getProvider();
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      let targetChainId = chainId;
      if (!targetChainId) {
        const state = await ((_a = config.storage) == null ? void 0 : _a.getItem("state")) ?? {};
        const isChainSupported = config.chains.some((x) => x.id === state.chainId);
        if (isChainSupported)
          targetChainId = state.chainId;
        else
          targetChainId = (_b = config.chains[0]) == null ? void 0 : _b.id;
      }
      if (!targetChainId)
        throw new Error("No chains found on connector.");
      if (!accountsChanged) {
        accountsChanged = this.onAccountsChanged.bind(this);
        provider.on("accountsChanged", accountsChanged);
      }
      if (!chainChanged) {
        chainChanged = this.onChainChanged.bind(this);
        provider.on("chainChanged", chainChanged);
      }
      if (!disconnect) {
        disconnect = this.onDisconnect.bind(this);
        provider.on("disconnect", disconnect);
      }
      let currentChainId = await this.getChainId();
      if (targetChainId && currentChainId !== targetChainId) {
        const chain = await this.switchChain({ chainId: targetChainId });
        currentChainId = chain.id;
      }
      return {
        accounts: accounts.map((x) => getAddress(x)),
        chainId: currentChainId
      };
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      const accounts = await provider.request({
        method: "eth_accounts"
      });
      return accounts.map((x) => getAddress(x));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const hexChainId = await provider.request({ method: "eth_chainId" });
      return fromHex(hexChainId, "number");
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ chainId }) {
      const provider = await this.getProvider();
      const chain = config.chains.find((x) => x.id === chainId);
      if (!chain) {
        throw new SwitchChainError(new ChainNotConfiguredError());
      }
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: numberToHex(chainId) }]
      });
      config.emitter.emit("change", { chainId });
      return chain;
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect() {
      config.emitter.emit("disconnect");
    },
    async getProvider() {
      return dist_default.wallet.ethProvider;
    }
  }));
}
var farcasterFrame = farcasterMiniApp;
farcasterFrame.type = "farcasterFrame";

// node_modules/@farcaster/miniapp-wagmi-connector/dist/index.js
var dist_default2 = farcasterMiniApp;
export {
  dist_default2 as default,
  farcasterFrame,
  farcasterMiniApp
};
//# sourceMappingURL=@farcaster_miniapp-wagmi-connector.js.map
